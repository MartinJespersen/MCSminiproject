class DutyRosterController is subclass of Global

instance variables
private dutyRoster: map Timeslot to Shift := {|->};
private employees: set of Employee := {};
private notificationManager: NotificationManager;
private time: Time;
private payment : Payment;
private employeesAssignedToShift: map Shift to set of Employee := {|->};
private shiftsEmployeeIsAssignedTo: map Employee to set of Shift := {|->};

inv dom(employeesAssignedToShift) subset rng(dutyRoster) and 
    dom(shiftsEmployeeIsAssignedTo) subset employees and
    dunion rng(employeesAssignedToShift) = dom(shiftsEmployeeIsAssignedTo) and
    dunion rng(shiftsEmployeeIsAssignedTo) = dom(employeesAssignedToShift);

operations

public DutyRosterController : NotificationManager * Payment ==> DutyRosterController
DutyRosterController(notifyMan, p) ==
(
    notificationManager := notifyMan;
    time := notificationManager.GetTime();
    payment := p;

);

public AddEmployeeToShift : Employee * Shift ==> ()
AddEmployeeToShift(employee, shift) ==
(
    dcl employeesAssignedToShiftTemp : set of Employee := {};
    dcl shiftsEmployeeIsAssignedToTemp : set of Shift := {};
    if shift in set dom(employeesAssignedToShift)
    then 
        employeesAssignedToShiftTemp := employeesAssignedToShift(shift) union {employee};
    if(employee in set dom(shiftsEmployeeIsAssignedTo)) 
    then 
        shiftsEmployeeIsAssignedToTemp := shiftsEmployeeIsAssignedTo(employee) union {shift};
    atomic(
        employeesAssignedToShift := 
            employeesAssignedToShift ++ {shift |-> employeesAssignedToShiftTemp};
        shiftsEmployeeIsAssignedTo := 
            shiftsEmployeeIsAssignedTo ++ {employee |-> shiftsEmployeeIsAssignedToTemp}
    )
)
pre IsEmployeePartOfDutyRoster(employee, employees) and 
    IsShiftPartOfDutyRoster(shift, rng(dutyRoster)) and
    IsEmployeePartOfShift(employee, employeesAssignedToShift(shift))
post employee in set employeesAssignedToShift(shift) and 
    shift in set shiftsEmployeeIsAssignedTo(employee);

public AddShiftToDutyRoster : Timeslot * Shift ==> ()
AddShiftToDutyRoster(timeslot,shift) == 
(
    dutyRoster := dutyRoster munion {timeslot |-> shift};
)
pre not IsShiftPartOfDutyRoster(shift, rng(dutyRoster)) and
    IsTimeslotPossible(timeslot, dom(dutyRoster));

public DeleteShiftFromDutyRoster: Shift ==> ()
DeleteShiftFromDutyRoster(shift) ==
(
    dcl shiftsEmployeeIsAssignedToTemp: map Employee to set of Shift := { |->};
    for all emp in set dom(shiftsEmployeeIsAssignedTo) do
        shiftsEmployeeIsAssignedToTemp := shiftsEmployeeIsAssignedToTemp munion {emp |-> shiftsEmployeeIsAssignedTo(emp) \ {shift}};
    atomic(
        dutyRoster := dutyRoster :-> {shift};
        employeesAssignedToShift := {shift} <-: employeesAssignedToShift;
        shiftsEmployeeIsAssignedTo := shiftsEmployeeIsAssignedToTemp;
    );
    notificationManager.DeleteNotificationsForShift(shift);

) 
pre IsShiftPartOfDutyRoster(shift, rng(dutyRoster));

public AddEmployeeToDutyRoster : Employee ==> ()
AddEmployeeToDutyRoster(emp) ==
    employees := employees union {emp}
pre not IsEmployeePartOfDutyRoster(emp, employees);

public DeleteEmployeeFromDutyRoster: Employee ==> ()
DeleteEmployeeFromDutyRoster(emp) == 
(
    dcl employeesAssignedToShiftTemp: map Shift to set of Employee := {|->};
    for all s in set dom(employeesAssignedToShift) do
        employeesAssignedToShiftTemp := 
            employeesAssignedToShiftTemp munion {s |-> employeesAssignedToShift(s) \ {emp}};
    atomic(
        employees := employees \ {emp};
        shiftsEmployeeIsAssignedTo := {emp} <-: shiftsEmployeeIsAssignedTo;
        employeesAssignedToShift := employeesAssignedToShiftTemp;
    );
    notificationManager.DeleteNotificationsForEmployee(emp);
)
pre IsEmployeePartOfDutyRoster(emp, employees);

public GetAvailableTimeslotsMatchingExpertise : Employee ==> set of Timeslot
GetAvailableTimeslotsMatchingExpertise(emp) ==
    let prof = emp.GetProfession()
    in
        return {t | t in set dom(dutyRoster) & 
            let shift = dutyRoster(t),
                mk_(startTime,-) = t 
                in
                    shift.IsShiftVacant(prof) and 
                    startTime >= time.GetTime() and 
                    emp not in set employeesAssignedToShift(shift)}
post RESULT subset dom(dutyRoster);

public GetAssignedTimeslots : Employee ==> set of Timeslot
GetAssignedTimeslots(emp) ==
    return {t | t in set dom dutyRoster & dutyRoster(t) in set shiftsEmployeeIsAssignedTo(emp)}
pre IsEmployeePartOfDutyRoster(emp, employees)
post RESULT subset dom dutyRoster;

public CreateNotification : Shift * Employee * nat ==> ()
CreateNotification(shift, emp, notificationTime) ==
    let mk_(startTime, -) = (inverse dutyRoster)(shift) in
        notificationManager.AddNotification(shift, emp, startTime - notificationTime)
pre IsShiftPartOfDutyRoster(shift, rng(dutyRoster)) and
    IsEmployeePartOfShift(emp, employeesAssignedToShift(shift)) and
    IsShiftInTheFuture(shift);

public DeleteNotifications : Shift * Employee ==> ()
DeleteNotifications(shift, emp) ==
    notificationManager.DeleteNotification(shift, emp)
pre IsEmployeePartOfShift(emp, employeesAssignedToShift(shift));

pure private IsShiftInTheFuture : Shift ==> bool
IsShiftInTheFuture(shift) ==
    let mk_(startTime, -) = (inverse dutyRoster)(shift) in
        return startTime > time.GetTime();

public PaymentOverPeriod: Employee * nat * nat ==> nat
PaymentOverPeriod(emp, from, until) ==
    payment.PaymentOverPeriod(emp, from, until)
pre from < until and 
    IsEmployeePartOfDutyRoster(emp, employees);

functions

private IsEmployeePartOfShift: Employee * set of Employee -> bool
IsEmployeePartOfShift(emp, employees) ==
    emp in set employees;

private IsEmployeePartOfDutyRoster : Employee * set of Employee -> bool
IsEmployeePartOfDutyRoster(emp, allEmp) == 
    emp.GetId() in set {empIter.GetId() | empIter in set allEmp};
    
public IsShiftPartOfDutyRoster : Shift * set of Shift -> bool
IsShiftPartOfDutyRoster(shift, allShifts) == 
    shift.GetId() in set {shiftIter.GetId() | shiftIter in set allShifts};

public IsTimeslotPossible : Timeslot * set of Timeslot -> bool
IsTimeslotPossible(timeslot, allTimeslots) == 
    let mk_(startTime, endTime) = timeslot in
        forall slot in set allTimeslots & 
            let mk_(setStartTime, setEndTime) = slot in
                endTime <= setStartTime or startTime >= setEndTime;



end DutyRosterController